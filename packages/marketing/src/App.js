import React from 'react';
import { Switch, Route, Router } from 'react-router-dom';
import { StylesProvider, createGenerateClassName } from '@material-ui/core/styles';

import Landing from './components/Landing';
import Pricing from './components/Pricing';

// CSS stuff. why does it break?
// (Note that the fix is unique to Material-UI...check docs if using other tools, might not break.)

// When we first added Header to container, and then ran locally with marketing and looked in
// localhost on browser, the styling seemed nice.
//
// BUT, when we deployed and looked in production, there were some issues:
//   - The header looked way too tall, for one. Its height was too high, and this did not have to do
//     with zoom level.
//
// Some general notes about CSS in mfe projects:
//   - Remember, as an inflexible requirement there needs to be zero coupling between child projects
//     and as a consequence this means that pages from different projects are going to look
//     different. ("It's just kind of a reality of developing micro-frontends.")
//   - So imagine that user starts on a page by marketing team, then navigates to page by auth team
//     and at that point new CSS gets loaded up to make all h1 the color green.
//   - But this is a single-page app...we are not reloading a new page each time, just loading new
//     content to the same page. So now this rule of 'make all h1 elements green' applies for the
//     rest of the time that the page is loaded or until it's overwritten. so when the user goes
//     back to the marketing page, all the h1 elements there will be green too!
//
// So to fix this, we need to learn about scoping CSS. How we do it depends on how our CSS is done:
//   - If it is all custom CSS written for a project, then it can hep to use a css-in-js library.
//     - This basically assigns randomly-generated class names like "h1_j1kj2j4" to elements to
//       prevent collisions...the library makes sure it's all scoped to very specific elements.
//   - If we are using Vue or Angular, there is built-in component style scoping.
//   - Also could just 'namespace' all CSS by hand.
//     - As in, we'd give auth h1 CSS names like '.auth h1 { color: 'green'; }' and then in the HTML
//       make sure it is '<div class="auth"><h1>I am green.</h1></div>'.
//     - But this is tricky if, for example, new engineers come in and don't know to do this. If
//       they naively just add CSS like 'h1 { ... }' then that will bleed out to other projects.
//   - OR, if the CSS is coming from a different component library like Material-UI, which already
//     has css-in-js built in, then in theory there shouldn't be any issues....but there is. Why?
//   - What about deliberately sharing CSS libraries among all projects? So just use one CSS library
//     through Bootstrap V4 and loading it up once?
//     - Totally possible, but remember this leads to some coupling. Like if in one project they
//       want to upgrade to Bootstrap V5, they can't really without checking if breaks another
//       project. Like maybe there are breaking changes in V5 you have to run by other team.
//
// Take a look at Landing.js component in marketing, and see how it's using Material-UI. There are
// also components in container using the same library, so even though css-in-js is used in both,
// there can still be collisions. (See comments there.)
//
// When we use this, and then look in production, we see that the class names are 'ma1', 'ma2', etc.
// So this prevents collisions with the styles generated by container and the other child projects.
//
// Of course need to do this for every project (technically every except one) to prevent collisions.
const generateClassName = createGenerateClassName({
  // Want to keep this short for production...
  productionPrefix: 'ma'
})

export default ({ history }) => {
  return (
    <div>
      <StylesProvider generateClassName={generateClassName}>
        {/* Originally was using a browser history here, but changed it due to policy explained in
        the App.js for container. The Router component lets us provide our own history object. */}
        <Router history={history}>
          <Switch>
            <Route exact path="/pricing" component={Pricing} />
            {/* If we use 'exact' here as well, then when going to /other or something, just */}
            {/* blank page. As in, the _marketing-dev-root div gets replaced with empty div.  */}
            <Route path="/" component={Landing} />
          </Switch>
        </Router>
      </StylesProvider>
    </div>
  );
};
